<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>EPI - Programowanie w języku JavaScript</title>
    <link href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
    <style>
      body { margin-top: 50px; margin-bottom: 50px; }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="row">
        <div class="col-sm-8 col-sm-offset-2">

<!-- generated content goes here -->

<h1 id="typy-danych-w-javascript">Typy Danych w JavaScript</h1>
<h2 id="number">Number</h2>
<p>Reprezentuje liczby całkowite i zmiennoprzecinkowe, np:</p>
<pre><code>var x = 1;
var y = 1.23;
var z = 2e-3;
</code></pre>
<h3 id="operatory-arytmetyczne-zwiazane-z-typem-number">Operatory arytmetyczne związane z typem Number</h3>
<h4 id="dodawanie">Dodawanie</h4>
<pre><code>var x = 1.25 + 1e-1  // ile to jest?
</code></pre>
<h4 id="odejmowanie-i-negacja-unary-minus">Odejmowanie i negacja (<em>unary minus</em>)</h4>
<pre><code>var x = 1.25 - 1;
var y = -0.4;
var z = -(-2);
</code></pre>
<h4 id="mnozenie">Mnożenie</h4>
<pre><code>var a = 8.82 * 1e2;
</code></pre>
<h4 id="dzielenie">Dzielenie</h4>
<pre><code>var a = 3 / 5;
</code></pre>
<h4 id="inkrementacja-i-dekrementacja">Inkrementacja i Dekrementacja</h4>
<pre><code>var a = 1;
a++;
++a;
++a;
a--;
--a;
// teraz wynosi a?
</code></pre>
<h4 id="modulo">Modulo</h4>
<pre><code>var a = 10 % 3; // a = 1
var b = 10 % 5; // a = 0
var c = -10 % 3; // a = 1, dlaczego?
</code></pre>
<h2 id="string">String</h2>
<p>Reprezentuje ciąg znaków</p>
<pre><code>var a = "Hello world";
var b = 'Hello world';
var c = 'c';
var d = '';
</code></pre>
<h3 id="operatory-zwiazane-z-typem-string">Operatory związane z typem String</h3>
<h4 id="konkatenacja">Konkatenacja</h4>
<p>Operator <code>+</code> pozwala na połączenie dwóch łańcuchów w jeden:</p>
<pre><code>var a = "Hello" + 'World!' // a = "HelloWorld!"
</code></pre>
<h2 id="boolean">Boolean</h2>
<p>Reprezentuje wartości logiczne, może przyjmować wartość <code>true</code> lub <code>false</code>:</p>
<pre><code>var a = true;
var b = false;
</code></pre>
<h3 id="operatory-dziaajace-na-wartosciach-logicznych">Operatory działające na wartościach logicznych</h3>
<h4 id="negacja">Negacja</h4>
<p>Zwraca wartość przeciwną do podanej, np:</p>
<pre><code>var a = !true; // a = false;
var b = !!true; // b = true;
var c = !false; // c = true;
</code></pre>
<h2 id="array">Array</h2>
<p>Reprezentuje tablicę (czyli uszeregowaną w kolejności kolekcję danych):</p>
<pre><code>var a = [1, 2, 3];
var b = [1, "hello"];
var c = [];
var d = Array(); // d = [];
var e = Array(true, 2.3); // e = [true, 2.3]
var d = [];
d[2] = 'surprise'; // d = [undefined, undefined, 'surprise']
</code></pre>
<h3 id="operatory-dziaajace-na-tablicach">Operatory działające na tablicach</h3>
<h4 id="operator-dostepu-do-elementu">Operator dostępu do elementu</h4>
<p>Dostęp do n-tego elementu tablicy <em>a</em> uzyskujemy pisząc <code>a[n-1]</code>, np:</p>
<pre><code>var a = [1, 2, 4];
var b = a[1]; // b = 2
var c = a[20]; // c = undefined
var d = a[-1]; // d = undefined
</code></pre>
<p>Jeśli elementu o danym <em>offsecie</em> nie ma w tablicy zwrócone zostanie <code>undefined</code>.</p>
<h2 id="object">Object</h2>
<p>Reprezentuje obiekt (najłatwiej rozumieć to jako zbiór rzeczy, które mają nazwę),
na przykład:</p>
<pre><code>var stanSklepu = {
    bulki: 3,
    mineralna: 5,
};

var szkola = {
    klasa1: ['jola', 'marcin'],
    klasa2: ['artur', 'gruby']
};
</code></pre>
<p>Pod nazwą stan sklepu rozumiemy objekt (<em>pojemnik na rzeczy</em>), który ma w sobie
coś nazwane <em>bulki</em> (i to coś ma wartość 3), oraz ma w sobie coś nazwane <em>mineralna</em>
i to coś ma wartość 5. Oczywiście myśląc abstrakcyjnie rozumiemy, że <code>stanSklepu</code>
zawiera w sobie wykaz produktów, ale najprościej myśleć o obiektach po prostu jako
o pojemnikach na inne rzeczy.</p>
<h3 id="operatory-dziaajace-na-obiektach">Operatory działające na obiektach</h3>
<h4 id="operator-dostepu-do-elementu-pola">Operator dostępu do elementu (pola)</h4>
<p>Dostęp do pól (nazwy dla zawartości obiektu nazywamy jego polami) uzyskać można na
dwa sposoby, np:</p>
<pre><code>var czlowiek = {
    korpus: ['klata', 'bice', 'wielkie cyce'],
    dol: ['noga lewa', 'noga prawa'],
    glowa: 'sama glowa'
};

var korpus = czlowiek.korpus; // korpus = ['klata', 'bice', 'wielkie cyce']
var glowa = czlowiek['glowa']; // glowa = 'sama glowa'
</code></pre>
<p>Jeśli tylko możesz stosuj pierwszą notację (z kropką), druga jest potrzeba, gdy
nazwę pola chcesz zbudować dynamicznie, na przykład:</p>
<pre><code>var szkola = {
    klasa1: ['ala', 'jan'],
    klasa2: ['bartek', 'zosia']
};

var starszaki = szkola['klasa' + '2']; // starszaki = ['bartek', 'zosia']
</code></pre>
<p>Podobnie można zapisywać do pól obiektów:</p>
<pre><code>var koszyk = {};
koszyk.jablka = 2;
koszyk['gruszki'] = 3;
// teraz masz 5 owoców :)
</code></pre>
<h2 id="null">null</h2>
<p><code>null</code> to specjalna wartość, którą można przypisać do zmiennej. Oznacza ona brak wartości.</p>
<h2 id="undefined">undefined</h2>
<p><code>undefined</code> to specjalna wartość, którą może mieć zmienna. Oznacza ona, że jej wartość jest nieznana.
<strong>Nigdy nie przypisuj <code>unefined</code> do zmiennej!</strong></p>
<pre><code>var a = [];
a[3] = 1; // a = [undefined, undefined, 1], pamiętasz z wyżej, prawda?
var b = [];
b[3] = undefined; // b = [undefined, undefined, undefined]
// Jak teraz rozróżnisz, które tam wsadziłeś, a które naprawdę jest undefined? Dlatego nie rób tak!
</code></pre>
<h2 id="nan">NaN</h2>
<p>Specjalna wartość <em>not a number</em>. Oznacza, że dana wielkość nie może być wyrażona jako liczba, np:</p>
<pre><code>var a = 10 / 0; // a = NaN
</code></pre>
<h1 id="operatory-logiczne">Operatory logiczne</h1>
<p>Operatory logiczne w JavaScript działają na dowolnych typach danych, a zwracają wartość logiczną.</p>
<h2 id="operator-rownosci">Operator równości (==)</h2>
<p>Porównuje dwie wartości, zwracając <code>true</code> jeśli są one takie same, lub <code>false</code> jeśli nie są:</p>
<pre><code>var a = (1 == 1); // a = true
var c = ('a' == 'A'); // c = false;
var b = (1 == "1"); // a = true, dlaczego i jak dokładnie się to dzieje
</code></pre>
<h2 id="operator-niewownosci">Operator niewówności (!=)</h2>
<p>Jego działanie jest przeciwne do działania operatora <code>=!</code>:</p>
<pre><code>var a = (1 != 1); // a = false;
// zauważ, że !(x == x) == (x != x), taka tam tautologia :)
</code></pre>
<h2 id="operator-dokadnej-rownosci">Operator dokładnej równości (===)</h2>
<p>Dokonuje porównania dwóch wartości zwracając <code>true</code> jeśli są one "dokładnie równe" sobie, lub
<code>false</code> jeśli jest odwrotnie.</p>
<pre><code>var a = (1 === 1); // a = true
var b = ("1" === 1); // b = false, dlaczego i jak się to dzieje?
</code></pre>
<p><strong>Używa się go tylko w wybranych sytuacjach.</strong></p>
<h2 id="operator-dokadnej-nierownosci">Operator dokładnej nierównośći (!==)</h2>
<p>Jeśli dwie wartości nie są sobie dokładnie równe zwraca <code>true</code>, w innym wypadku <code>false</code>.</p>
<pre><code>var a = (1 !== "1"); // true
</code></pre>
<h2 id="operator-mniejszosci">Operator mniejszości (&lt;)</h2>
<p>Dla liczb dokonuje porównania:</p>
<pre><code>var a = 2 &lt; 3; // true
</code></pre>
<p>Dla łańcuchów znaków i tablic dokonuje porównania leksykograficznego:</p>
<pre><code>var a = 'alamakota' &lt; 'hello'; // true
var b = [1,2,4] &gt; [1,2,1]; // true
</code></pre>
<p>Dla obiektów zawsze zwraca false:</p>
<pre><code>var a = {};
var b = {a: 1};
var c = a &lt; b; // false
</code></pre>
<h2 id="operator-sabej-mniejszosci">Operator słabej mniejszości (&lt;=)</h2>
<p>Działa jak operator mniejszości, jednak w porównaniach dopuszcza nierówność słabą.</p>
<h2 id="operator-wiekszosci">Operator większości</h2>
<p>Działa jak operator mniejszości, jednak nierówność skierowana jest w drugą stronę.</p>
<h2 id="operator-sabej-wiekszosci">Operator słabej większości</h2>
<p>Działa jak operator większości, jednak dopuszcza słabą nierówność w porównaniach.</p>
<h1 id="zmienne">Zmienne</h1>
<p>Zmienne w javascript deklaruje się korzystając ze słowa kluczowego <code>var</code>:</p>
<pre><code>var mojazmienna;
</code></pre>
<p>Po zadeklarowaniu zmienna nie ma określonej wartości:</p>
<pre><code>var a; // a ma wartość undefined;
</code></pre>
<p>Można jednocześnie zadeklarować zmienną i ją przypisać, albo zrobić to później:</p>
<pre><code>var a;
a = 1; // ok
var b = 'odrazu'; // też ok
</code></pre>
<p>Zmiennej można przypisać wartośc kilka razy:</p>
<pre><code>var a = 1;
var b = 2; // a = 1, b = 2
a = 2; // a = 2, b = 2
a = a + b // a = 4, b = 2
b = 1; // a = 4, b = 1
</code></pre>
<h1 id="sterowanie-przepywem">Sterowanie Przepływem</h1>
<h2 id="instrukcje-warunkowe">Instrukcje warunkowe</h2>
<h3 id="ifelse">If/else</h3>
<p>Sposobem na podejmowane decyzj w języku JavaScript jest instrukcja
warunkowa <code>if/else</code> o składni:</p>
<pre><code>if (&lt;warunek&gt;) {
    // ten blok wykona się jeśli warunek jest true
} else {
    // ten blok wykona się jeśli warunek jest false
}
</code></pre>
<p>Na przykład:</p>
<pre><code>if (1 == 1) {
    console.log('Wszystko ok...');
} else {
    console.log('Świat zwariował...');
}
</code></pre>
<p>Gałąż <code>else</code>, jest opcjonalna, czyli poprawny jest zapis:</p>
<pre><code>if (1 == 1) {
    console.log('Wszystko ok...');
}
</code></pre>
<h3 id="switch">Switch</h3>
<p>Gdy zachodzi potrzeba rozgałęzienia logiki na więcej niż 2 sposoby możesz skorzystać
z instrukcji <code>switch</code>, na przykład:</p>
<pre><code>var expression = "Banany";
switch (expression) {
   case "Pomarancze":
      document.write("Pomarańcze są za 10zł. Ma być?&lt;br&gt;");
      break;
   case "Jablka":
      document.write("Jabłka są za 5zł. Ma być?&lt;br&gt;");
      break;
   case "Banany":
      document.write("Banany są za 9zł. Ma być?&lt;br&gt;");
      break;
   case "Wisnie":
      document.write("Wiśnie są za 30zł. Ma być?&lt;br&gt;");
      break;
   default:
      document.write("Niestety, nie mamy czego chcesz.&lt;br&gt;");
}
</code></pre>
<p>Domyślnie switch wykazuje tzw. fall-through. Spróbuj wykasować instrukcje <code>break</code>
w poszczególnych gałęziach i zobacz co się dzieje.</p>
<h2 id="petle">Pętle</h2>
<h3 id="while">While</h3>
<p>Blok wewnątrz pętli while wykonuje się tak długo, jak warunek w nawiasie jest prawdziwy:</p>
<pre><code>var i = 0;
while (i &lt; 10) {
    console.log(i);
    i++;
}
// 0
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
</code></pre>
<h3 id="do-while">Do-while</h3>
<p>Działanie analogiczne jak w przypadku <code>while</code>, jednak warunek sprawdzany jest dopiero
po wykonaniu bloku:</p>
<pre><code>var i = 3;
while (i &lt; 2) {
    console.log(i);
    i++;
}
// 3
</code></pre>
<h3 id="for">For</h3>
<p>Pętla for pozwala na jednoczesną deklarację zmiennej, sprawdzenie warunku i zmianę
zmiennej:</p>
<pre><code>for(var i = 0; i &lt; 2; i++) {
    console.log(i)
}
// 0
// 1
</code></pre>
<h1 id="do-samodzielnego-sprawdzenia">Do samodzielnego sprawdzenia</h1>
<p>I. Ile to jest? Dlaczego?</p>
<pre><code>2 + "2"   
2 + ''
true + false
</code></pre>
<p>II. Jaką wartość logiczną mają poniższe wyrażenia? Dlaczego?</p>
<pre><code>1 == "1"
1 + 1 == 2
1 - 1 == '0'
1 - 1 === 0
''
{}
[]
10 / 0 == 20 / 0
1 == 0.9999999999999999999999999999
</code></pre>
<p>III. Jaką wartość mają na koniec zmienne a i b?</p>
<pre><code>var a = 1;
var b = 1;
a = a + (b++);
b = b + (++a);
</code></pre>
<p>IV. Wytłumacz:</p>
<pre><code>var a = 1;
var b = 2;
var c = a++; // a = 2, c = 1
var d = ++b; // d = 3, b = 3

// ale

var t1 = [];
for (var i = 0; i &lt; 2; i++) {
    t1[i] = i;
}

var t2 = [];
for (var i = 0; i &lt; 2; ++i) {
    t[i] = i;
}

// t1 = [0, 1], t2 = [0, 1]
</code></pre>
<p>Dlaczego?</p>

       </div>
      </div>
    </div>
  </body>
</html>

